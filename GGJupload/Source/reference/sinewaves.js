/*!
 _______ _____ __   _ _______      _  _  _ _______ _    _ _______ _______
 |______   |   | \  | |______      |  |  | |_____|  \  /  |______ |______
 ______| __|__ |  \_| |______      |__|__| |     |   \/   |______ ______|

 sine-waves v0.3.0 <https://github.com/isuttell/sine-waves>
 Contributor(s): Isaac Suttell <isaac@isaacsuttell.com>
 Last Build: 2014-12-03
 Do not edit this file. It is created from the src/ folder.

 EDITED 2017-01-21 by Jason Charney.
 This file is only here for reference. Don't use it.  Seriously. Just don't. I'll make something better soon.
*/
(function(root, factory) {
  'use strict';
  if (typeof define === 'function' && typeof define.amd === 'object') {
    define([], function() {
      return factory(root);
    });
  } else
    root.SineWaves = factory(root);
})(this, function() {
  'use strict';

/************************************************
 * @file  Polyfills for older browsers
 * @author  Isaac Suttell
 * @editor  Jason Charney
 ************************************************/

/**
 * Bind polyfill
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind
 */
/* istanbul ignore next */
if (!Function.prototype.bind) {
  Function.prototype.bind = function(oThis) {
    if (typeof this !== 'function') {
      // closest thing possible to the ECMAScript 5
      // internal IsCallable function
      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
    }

    var aArgs   = Array.prototype.slice.call(arguments, 1);
    var fToBind = this;
    var fNOP    = function() {};
    var fBound  = function() {
      return fToBind.apply(this instanceof fNOP &&
        oThis ? this : oThis,
        aArgs.concat(Array.prototype.slice.call(arguments)));
    };

    fNOP.prototype   = this.prototype;
    fBound.prototype = new fNOP(); // jshint ignore:line

    return fBound;
  };
}

/**
 * Request Animation Polyfill
 * https://gist.github.com/paulirish/1579671
 *
 * @type {Array}
 */
/* istanbul ignore next */
var vendors = ['ms', 'moz', 'webkit', 'o'];
/* istanbul ignore next */
for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
  window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
  window.cancelAnimationFrame  = window[vendors[x] + 'CancelAnimationFrame'] ||
    window[vendors[x] + 'CancelRequestAnimationFrame'];
}

/* istanbul ignore next */
if (!window.requestAnimationFrame) {
  var lastFrameTime = 0;
  window.requestAnimationFrame = function(callback) {
    var currTime = new Date().getTime();
    var timeToCall = Math.max(0, 16 - (currTime - lastFrameTime));
    var id = window.setTimeout(function() {
        callback(currTime + timeToCall);
      },
      timeToCall
    );
    lastFrameTime = currTime + timeToCall;
    return id;
  };
}

/* istanbul ignore next */
if (!window.cancelAnimationFrame) {
  window.cancelAnimationFrame = function(id) {
    clearTimeout(id);
  };
}

/************************************************
 * @file  Constants
 * @author  Isaac Suttell
 * @editor  Jason Charney
 ************************************************/

var PI180   = Math.PI / 180;    // Radian conversion
var PI2     = Math.PI * 2;
var HALFPI  = Math.PI / 2;

/************************************************
 * @file  General utility functions
 * @author  Isaac Suttell
 * @editor  Jason Charney
 ************************************************/

/**
 * Utilities wrapper
 *
 * @type    {Object}
 * NOTE: Why dind't you just use the "typeof" variable for most of this?
 */
var Utilities = {
  // STATIC METHODS
  isType : function(obj, type) {          // Check to see if a var is a speficied type
    var result = {}.toString.call(obj).toLowerCase();
    return result === '[object ' + type.toLowerCase() + ']';
  },
  isFunction : function(fn) {             // Checks to see if var is a function
    return isType(fn, 'function');
  },
  isString : function(str) {              // Checks to see if var is a string
    return isType(str, 'string');
  },
  isNumber : function(num) {              // Checks to see if var is a number
    return isType(num, 'number');
  },
  shallowClone : function(src) {          // Create a clone of an object
    var dest = {};
    for (var i in src) {
      if (src.hasOwnProperty(i)) {
        dest[i] = src[i];
      }
    }
    return dest;
  },
  defaults : function(dest, src) {        // Basic Extend Function
    if (!isType(src, 'object')) { src = {}; }
    var clone = shallowClone(dest);
    for (var i in src) {
      if (src.hasOwnProperty(i)) {
        clone[i] = src[i];
      }
    }
    return clone;
  },
  degreesToRadians : function(degrees) {        // Convert degrees to radians for rotation function
    if (!isType(degrees, 'number'))
      throw new TypeError('Degrees is not a number');
    return degrees * PI180;
  },
  getFn : function(obj, name, def) {            // You can either directly specify a easing function, use a built in function or default to the basic SineInOut
    if (isFunction(name))
      return name;
    else if (isString(name) && isFunction(obj[name.toLowerCase()]))
      return obj[name.toLowerCase()];
    else
      return obj[def];
  }
};

var isType           = Utilities.isType;
var isFunction       = Utilities.isFunction;
var isString         = Utilities.isString;
var isNumber         = Utilities.isNumber;
var shallowClone     = Utilities.shallowClone;
var defaults         = Utilities.defaults;
var degreesToRadians = Utilities.degreesToRadians;
var getFn            = Utilities.getFn;

/************************************************
 * @file  Left to right easing functions
 * @author Isaac Suttell
 * @editor Jason Charney
 ************************************************/

/**
 * This holds all of the easing objects and can be added to by the user.
 * Each easing function (except Ease.linear ) controls how string each wave is from left to right.
 *
 * @type    {Object}
 *
 * @param  {Number} percent   where in the line are we?
 * @param  {Number} amplitude the current strength
 *
 * @return {Number}           the new strength
 */
var Ease = {
  // STATIC METHODS
  linear : function(percent, amplitude) {     // Do not apply any easing
    return amplitude;
  },
  sinein : function(percent, amplitude) {
    return amplitude * (Math.sin(percent * Math.PI - HALFPI) + 1) * 0.5;
  },
  sineout : function(percent, amplitude) {
    return amplitude * (Math.sin(percent * Math.PI + HALFPI) + 1) * 0.5;
  },
  sineinout : function(percent, amplitude) {
    return amplitude * (Math.sin(percent * PI2 - HALFPI) + 1) * 0.5;
  }
};

/************************************************
 * @file  Sine Wave functions
 * @author Isaac Suttell
 * @editor Jason Charney
 ************************************************/

// NOTE: These waves are STATIC!
/**
 * Holds the different types of waves
 *
 * @type    {Object}
 */
var Waves = {
  // STATIC METHODS
    sine : function(x) {    // Default sine wave
      return Math.sin(x);
    },
    //sin : Waves.sine,        // @alias for Waves.sine
    sign : function(x) {        // Sign polyfill, https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
      x = +x; // convert to a number
      if (x === 0 || isNaN(x))
        return x;
      return x > 0 ? 1 : -1;
    },
    square : function(x) {
      return Waves.sign(Math.sin(x * PI2));
    },

    sawtooth : function(x) {
      return (x - Math.floor(x + 0.5)) * 2;
    },

    triangle : function(x) {
      return Math.abs(Waves.sawtooth(x));
    }

};

/**
 * Alias for Sine
 *
 * @alias
 * @type    {Function}
 */
Waves.sin = Waves.sine;


/************************************************
 * @file    Constructor and animation controller
 * @author  Isaac Suttell
 * @editor  Jason Charney
 ************************************************/

var defaultWave = {     // Default values for each line created
  timeModifier  :  1,
  amplitude     : 50,
  wavelength    : 50,
  segmentLength : 10,
  lineWidth     :  1,
  strokeStyle   : 'rgba(255, 255, 255, 0.2)',
  type          : 'Sine'
};

/**
 * Takes either pixels or percents and calculates how wide the sine waves should be
 *
 * @param     {Mixed}    value    0, '10px', '90%'
 * @param     {Number}   width    Width for percentages
 *
 * @return    {Number}
 */
function getWaveWidth(value, width) {
  if (Utilities.isType(value, 'number'))
    return value;

  value = value.toString();
  if (value.indexOf('%') > -1) {
    value = parseFloat(value);
    if (value > 1)
      value /= 100;
    return width * value;
  } else if (value.indexOf('px') > -1) {
    return parseInt(value, 10);
  }
}

// Static Method Access
SineWaves.prototype.Waves = Waves;  // Make the Wave function available
SineWaves.prototype.Ease  = Ease;   // Make the Ease function available

/**
 * Generates multiple customizable animated sines waves using a canvas element.
 * Supports retina displays and limited mobile support
 */
var SineWaves = function(options) {
  this.options = Utilities.defaults(this.options, options);   // Save a reference

  // Make sure we have a canvas
  this.el = this.options.el;
  delete this.options.el;
  if (!this.el)
    throw 'No Canvas Selected';

  this.ctx = this.el.getContext('2d');      // Setup the context for reference

  // Do we have any waves
  this.waves = this.options.waves;
  delete this.options.waves;
  if (!this.waves || !this.waves.length)
    throw 'No waves specified';

  this.dpr = window.devicePixelRatio || 1;      // DPI

  // Setup canvas width/heights
  this.updateDimensions();
  window.addEventListener('resize', this.updateDimensions.bind(this));

  // If the user supplied a resize event or init call it
  this.setupUserFunctions();

  this.easeFn   = Utilities.getFn(Ease, this.options.ease, 'linear');   // Setup Easing
  this.rotation = Utilities.degreesToRadians(this.options.rotate);      // Set the canvas rotation

  if (Utilities.isType(this.options.running, 'boolean'))                // Should we start running?
    this.running = this.options.running;

  this.setupWaveFns();    // Assign wave functions
  this.loop();            // Start the magic
}

SineWaves.prototype = {
  // Attributes
  options : {   // Default options
    speed      : 10,
    rotate     :  0,
    ease       : 'Linear',
    wavesWidth : '95%'
  },
  time : 0,           // Starting time
  running : true,     // Animation Status

  // Methods
  setupWaveFns : function() {         // Get the user wave function or one of the built in functions
    var index = -1;
    var length = this.waves.length;
    while (++index < length)
      this.waves[index].waveFn = Utilities.getFn(Waves, this.waves[index].type, 'sine');
  },
  setupUserFunctions : function() {   // Set up the user resize event in the initialize event
    // User Resize Function
    if (Utilities.isFunction(this.options.resizeEvent)) {
      this.options.resizeEvent.call(this);
      window.addEventListener('resize', this.options.resizeEvent.bind(this));
    }

    // User initialize
    if (Utilities.isFunction(this.options.initialize))
      this.options.initialize.call(this);
  },
  getDimension : function(dimension) {  // Get the height or width from a number, function or fallback to the default client dimension
    if (Utilities.isNumber(this.options[dimension]))
      return this.options[dimension];
    else if (Utilities.isFunction(this.options[dimension]))
      return this.options[dimension].call(this, this.el);
    else if (dimension === 'width')
      return this.el.clientWidth;
    else if (dimension === 'height')
      return this.el.clientHeight;
  },
  updateDimensions : function() {   // Internal resize event to make the canvase fill the screen
    // Dimensions
    var width  = this.getDimension('width');
    var height = this.getDimension('height');

    // Apply DPR for retina devices
    this.width  = this.el.width  = width  * this.dpr;
    this.height = this.el.height = height * this.dpr;

    // Scale down
    this.el.style.width  = width  + 'px';
    this.el.style.height = height + 'px';

    this.waveWidth = getWaveWidth(this.options.wavesWidth, this.width);   // Padding
    this.waveLeft = (this.width - this.waveWidth) / 2;                    // Center it
    this.yAxis    = this.height / 2;                                      // Vertical center
  },
  clear : function() {              // Clear the canvas so we can redraw
    this.ctx.clearRect(0, 0, this.width, this.height);
  },
  update : function(time) {   // This updates each of the lines each loop we're running
    this.time -= 0.007;
    if (typeof time === 'undefined')
      time = this.time;

    var index = -1;
    var length = this.waves.length;

    this.clear();     // Clear canvas

    this.ctx.save();

    if (this.rotation > 0) {
      this.ctx.translate( this.width / 2,  this.height / 2);
      this.ctx.rotate(this.rotation);
      this.ctx.translate(-this.width / 2, -this.height / 2);
    }

    // Draw each line
    while (++index < length) {
      var timeModifier = this.waves[index].timeModifier || 1;
      this.drawWave(time * timeModifier, this.waves[index]);
    }
    this.ctx.restore();

    index = length = void 0;  // Clean up
  },
  getPoint : function(time, position, options) {    // Calculate the x, y coordinates of a point in a sine wave
    var x = (time * this.options.speed) + (-this.yAxis + position) / options.wavelength;
    var y = options.waveFn.call(this, x, Waves);

    var amplitude = this.easeFn.call(this, position / this.waveWidth, options.amplitude); // Left and Right Sine Easing

    x = position      + this.waveLeft;
    y = amplitude * y + this.yAxis;

    return { x: x, y: y };
  },
  drawWave : function(time, options) {  // Draws one line on the canvas
    options = Utilities.defaults(defaultWave, options);   // Setup defaults

    // Styles
    this.ctx.lineWidth    = options.lineWidth * this.dpr;
    this.ctx.strokeStyle  = options.strokeStyle;
    this.ctx.lineCap      = 'butt';
    this.ctx.lineJoin     = 'round';
    this.ctx.beginPath();

    // Starting Line
    this.ctx.moveTo(0, this.yAxis);
    this.ctx.lineTo(this.waveLeft, this.yAxis);

    var i;
    var point;

    for (i = 0; i < this.waveWidth; i += options.segmentLength) {
      point = this.getPoint(time, i, options);  // Calculate where the nex point is
      this.ctx.lineTo(point.x, point.y);        // Draw to it
      point = void 0;                           // Clean Up
    }

    i = options = void 0;                       // Clean up
    this.ctx.lineTo(this.width, this.yAxis);    // Ending Line
    this.ctx.stroke();                          // Stroke it
  },
  loop : function() {                           // Animation Loop Control
    if (this.running === true)
      this.update();

    window.requestAnimationFrame(this.loop.bind(this));
  }
}


  return SineWaves;
});
